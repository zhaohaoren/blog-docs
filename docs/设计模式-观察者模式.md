# 【设计模式】观察者模式

本文主要介绍观察者模式的概念和用法，以及jdk提供的观察者模式支持。

## 模式背景

我们在项目开发中会存在当一个对象发生变化的时候，其他的一些对象也需要跟着变更自己的状态或者去做一些操作。比如一个微信公众号，当号主发布了一篇文章之后，所有关注了这个公众号的用户都会受到该文章的推送。这种一个对象的变化，需要引起了多个对象变化的方案可以使用观察者模式。我们可能听得更多的是发布订阅模式（特别是学习消息队列时候），其实也就是观察者模式。

## 定义&概念

观察者模式：定义对象之间的一种一对多的依赖关系，是的当一个对象状态发生变化的时候，其相关依赖对象皆得到通知并被自动更新。**观察者模式的别名有：发布-订阅（publish/subscribe）模式**，**模型-视图（model/view）模式**，源-监听（source/listener）模式，从属者(dependents)模式。观察者模式是一种**对象行为型模式**。

## 原理

既然叫观察者模式，那么整个模式中核心的角色自然就2个：**观察者**和**被观察者**。现在我们希望被观察者的变化，能够通知到观察者。





**组成要素**

- 目标：需要被观察的对象，内部有一个集合存储若干个观察者。一旦该目标类发生变化，通知内部所有的观察者。提供观察者添加删除操作。
- 具体目标：目标的实现类或者子类。主要是为了扩展目标类。
- 观察者：一般定义为接口，接口声明了更新数据的方法。
- 具体观察者：维护一个指向具体目标对象的引用。

### jdk观察者模式



## UML



## 实现

抽象目标

```java
public abstract class AllyControlCenter {
    /**
     * 战队名
     */
    protected String allyName;
    /**
     * 存储观察者的集合
     */
    protected ArrayList<Observer> players = new ArrayList<>();


    public String getAllyName() {
        return allyName;
    }

    public void setAllyName(String allyName) {
        this.allyName = allyName;
    }


    /**
     * 注册方法，对目标类添加新的观察者
     */
    public void join(Observer obs) {
        System.out.println(obs.getName() + " join " + allyName);
        players.add(obs);
    }

    /**
     * 注销方法：移除观察者
     */
    public void quit(Observer obs) {
        System.out.println(obs.getName() + " leave " + allyName);
        players.remove(obs);
    }

    /**
     * 抽象通知方法，通知所有的观察者
     */
    public abstract void notifyObserver(String name);


}
```

具体目标

```java
public class ConcreteAllyControlCenter extends AllyControlCenter {

    public ConcreteAllyControlCenter(String name) {
        this.allyName = name;
        System.out.println("create team:" + name);
    }

    @Override
    public void notifyObserver(String name) {
        System.out.println("notify all friends! " + name + " is attacked!");
        for (Observer player : players) {
            // 调用除了自己以外的盟友
            if (!player.getName().equalsIgnoreCase(name)) {
                player.help();
            }
        }
    }
}
```

抽象观察

```java
public interface Observer {
    String getName();

    void setName(String name);

    /**
     * 帮助队友的方法
     */
    void help();

    /**
     * 申明遭受攻击的方法，即观察者观察到了后，通知哪些对象
     */
    void beAttacked(AllyControlCenter acc);
}
```

具体观察

```java
public class Player implements Observer {
    private String name;

    public Player(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void help() {
        System.out.println(name + " help you!");
    }

    @Override
    public void beAttacked(AllyControlCenter acc) {
        System.out.println(name + " is attacked!");
        acc.notifyObserver(name);
    }
}
```

客户端

```java
//创建需要被观察的目标对象
ConcreteAllyControlCenter team = new ConcreteAllyControlCenter("team1");
//定义四个观察者
Observer player1, player2, player3, player4;
player1 = new Player("A");
team.join(player1);
player2 = new Player("B");
team.join(player2);
player3 = new Player("C");
team.join(player3);
player4 = new Player("D");
team.join(player4);
//让某一个遭受攻击
player2.beAttacked(team);
```

## 优缺点

### 优点

### 缺点

## 使用场景

## 总结



# 附

相关代码：https://github.com/zhaohaoren/design_pattern_tutorial

如有代码和文章问题，还请指正！感谢！