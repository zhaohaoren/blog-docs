---
title: 【读书笔记】深入理解Java虚拟机
date: 2020-05-10 01:09:36
tags:
---

深入理解Java虚拟机（第3版）| 作者：周志明 | 豆瓣评分：9.6

<!-- more -->

### 前言

作者给了一些不错的学习资源。随意挑些我感兴趣的：《Java虚拟机规范》《垃圾回收算法手册：自动内存管理的艺术》，《Java性能优化权威指南》，https://wiki.openjdk.java.net/display/HotSpot/Main

致谢

# 第一部分　走近Java

## 第1章　走近Java 2

### 1.1　概述 2

一些优点，注意标注一点：避免了**绝大部分**内存泄漏和指针越界问题。

### 1.2　Java技术体系 3

很好的一个提炼：

- JDK是用于支持Java程序开发的最小环境

- JRE是支持Java程序运行的标准环境

![image-20200325191408845](:book-深入理解Java虚拟机/java_structs.png)

#### 2.1.3　Java发展史 4

JDK各个版本的发展史。一些标注：

- 2018年3月，Oracle正式停止维护Java EE，禁止JavaEE再使用Java商标，取而代之的将是Jakarta EE。
- Oracle收购Sun对于Java的开源推动作用：带来很重的商业气息，但是也带来比之前更强的活力。【我也一直认为一个开源产品需要有一个好的发展模式来推动着，不然发展就会很缓慢。hadoop这些就是个例子。现在开源都需要找到适合自己的出路，而不是专门技术宅式的写代码】

### 1.4　Java虚拟机家族 12

#### 1.4.1　虚拟机始祖：Sun Classic/Exact VM 12

- 世界上第一款商用Java虚拟机，JDK 1.0发布就使用的ClassicVM。

- 只能使用纯解释器方式来执行Java代码
- JDK 1.2发布了Exact VM的虚拟机，具备现代高性能虚拟机雏 形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。

#### 1.4.2　武林盟主：HotSpot VM 13

- JDK 1.3时，HotSpot VM成为默认虚拟机。他是外部引入的（“Longview Technologies”的小公司设计的）

#### 1.4.3　小家碧玉：Mobile/Embedded VM 14

- 主要是服务于终端市场的，但是现在Android和IOS已经霸占了。很小众主要做嵌入式产品的。

#### 1.4.4　天下第二：BEA JRockit/IBM J9 VM 15

- 和HotSpot并称为“三 大商业Java虚拟机”的另外两位：JRockit和IBM J9

#### 1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16

- 一类与特定硬件平台绑定、软硬件配合工作的专有虚拟机，往往能够实现 更高的执行性能，或提供某些特殊的功能特性。
- Liquid VM不需要操作系统的支持，它自己本 身实现了一个专用操作系统的必要功能。
- Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬 件Vega系统上的Java虚拟机

#### 1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17

- 它们只能称作“虚拟机”，而不能称作“Java虚拟机”。
- Harmony并没有通过TCK认证，主要也是Sun的阻扰，目前没啥用，但是他的代码很多被吸收进其他JDK以及Android的SDK中。
- Dalvik是Android上的虚拟机，它没有遵循《Java虚拟机规范》，不能直接执行Java的Class文件。后来出了ART虚拟机替换了该虚拟机。

#### 1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18

- 微软为了windows支持java开发的虚拟机，结果被sun玩死了。

#### 1.4.8　百家争鸣 19

- 这些虚拟机大多是试验品，不是商用的。

## 1.5　展望Java技术的未来 21

### 1.5.1　无语言倾向 21

- 在HotSpot基础上诞生的Graal VM，支持多种语言在其上运行。Run Programs Faster Anywhere
- 一个在HotSpot虚拟机基础上增强而成的跨语言全栈虚拟机。

### 1.5.2　新一代即时编译器 23

- 首先了解一下什么是`即时编译器（JIT）`：一般情况下，Java代码都会先被编译成字节码，然后通过解释器执行，这种解释执行可以让程序获得比较好的启动时间，不需要编译那样久。在程序执行中某些被频繁执行的方法或者代码块，JVM会将其认定为**热点代码**，在运行中JVM会将这些热点代码通过即时编译器编译成与本地平台相关的机器码来获取更高的执行效率。

- HotSpot虚拟机中含有两个即时编译器：
  - C1：编译耗时短但输出代码优化程度较低的客户端编译器
  - C2：编译耗时长但输出代码优化质量也更高的服务端编译器
  - 它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统。

- JDK 10中HotSpot又加入了一个全新的即时编译器：Graal编译器，它以C2编译器替代者的身份登场的

### 1.5.3　向Native迈进 24

- java一直都将软件服务作为其重点领域，就是作为一个服务一直在那跑着。但是如今微服务以及无服务架构的流行，java也需要对其做改进来优化使用（java）
- 总结的来说：以前的java程序是一个单体服务，长时间的在那运行着，启动一般都比较慢，也都不会频繁的重它。但是微服务，或者无服务（一种函数计算服务新模式）这些的特点就是可以频繁重启，资源要求不高，但是数量很多，这就需要我们最好能启动快，资源占用小。所以java使用提前编译来支持这种模式。
- 提前编译主要就是将即时编译的东西提前就给其编译处理好了。

1.5.4　灵活的胖子 26
1.5.5　语言语法持续增强 27
1.6　实战：自己编译JDK 29
1.6.1　获取源码 29
1.6.2　系统需求 31
1.6.3　构建编译环境 33
1.6.4　进行编译 34
1.6.5　在IDE工具中进行源码调试 36
1.7　本章小结 39
第二部分　自动内存管理
第2章　Java内存区域与内存溢出异常 42
2.1　概述 42
2.2　运行时数据区域 42
2.2.1　程序计数器 43
2.2.2　Java虚拟机栈 43
2.2.3　本地方法栈 44
2.2.4　Java堆 44
2.2.5　方法区 46
2.2.6　运行时常量池 47
2.2.7　直接内存 47
2.3　HotSpot虚拟机对象探秘 48
2.3.1　对象的创建 48
2.3.2　对象的内存布局 51
2.3.3　对象的访问定位 52
2.4　实战：OutOfMemoryError异常 53
2.4.1　Java堆溢出 54
2.4.2　虚拟机栈和本地方法栈溢出 56
2.4.3　方法区和运行时常量池溢出 61
2.4.4　本机直接内存溢出 65
2.5　本章小结 66
第3章　垃圾收集器与内存分配策略 67
3.1　概述 67
3.2　对象已死？ 68
3.2.1　引用计数算法 68
3.2.2　可达性分析算法 70
3.2.3　再谈引用 71
3.2.4　生存还是死亡？ 72
3.2.5　回收方法区 74
3.3　垃圾收集算法 75
3.3.1　分代收集理论 75
3.3.2　标记-清除算法 77
3.3.3　标记-复制算法 78
3.3.4　标记-整理算法 79
3.4　HotSpot的算法细节实现 81
3.4.1　根节点枚举 81
3.4.2　安全点 82
3.4.3　安全区域 83
3.4.4　记忆集与卡表 84
3.4.5　写屏障 85
3.4.6　并发的可达性分析 87
3.5　经典垃圾收集器 89
3.5.1　Serial收集器 90
3.5.2　ParNew收集器 92
3.5.3　Parallel Scavenge收集器 93
3.5.4　Serial Old收集器 94
3.5.5　Parallel Old收集器 95
3.5.6　CMS收集器 96
3.5.7　Garbage First收集器 98
3.6　低延迟垃圾收集器 104
3.6.1　Shenandoah收集器 105
3.6.2　ZGC收集器 112
3.7　选择合适的垃圾收集器 121
3.7.1　Epsilon收集器 121
3.7.2　收集器的权衡 121
3.7.3　虚拟机及垃圾收集器日志 122
3.7.4　垃圾收集器参数总结 127
3.8　实战：内存分配与回收策略 129
3.8.1　对象优先在Eden分配 130
3.8.2　大对象直接进入老年代 131
3.8.3　长期存活的对象将进入老年代 132
3.8.4　动态对象年龄判定 134
3.8.5　空间分配担保 135
3.9　本章小结 137
第4章　虚拟机性能监控、故障处理工具 138
4.1　概述 138
4.2　基础故障处理工具 138
4.2.1　jps：虚拟机进程状况工具 141
4.2.2　jstat：虚拟机统计信息监视工具 142
4.2.3　jinfo：Java配置信息工具 143
4.2.4　jmap：Java内存映像工具 144
4.2.5　jhat：虚拟机堆转储快照分析工具 145
4.2.6　jstack：Java堆栈跟踪工具 146
4.2.7　基础工具总结 148
4.3　可视化故障处理工具 151
4.3.1　JHSDB：基于服务性代理的调试工具 152
4.3.2　JConsole：Java监视与管理控制台 157
4.3.3　VisualVM：多合-故障处理工具 164
4.3.4　Java Mission Control：可持续在线的监控工具 171
4.4　HotSpot虚拟机插件及工具 175
4.5　本章小结 180
第5章　调优案例分析与实战 181
5.1　概述 181
5.2　案例分析 181
5.2.1　大内存硬件上的程序部署策略 182
5.2.2　集群间同步导致的内存溢出 184
5.2.3　堆外内存导致的溢出错误 185
5.2.4　外部命令导致系统缓慢 187
5.2.5　服务器虚拟机进程崩溃 187
5.2.6　不恰当数据结构导致内存占用过大 188
5.2.7　由Windows虚拟内存导致的长时间停顿 189
5.2.8　由安全点导致长时间停顿 190
5.3　实战：Eclipse运行速度调优 192
5.3.1　调优前的程序运行状态 193
5.3.2　升级JDK版本的性能变化及兼容问题 196
5.3.3　编译时间和类加载时间的优化 200
5.3.4　调整内存设置控制垃圾收集频率 203
5.3.5　选择收集器降低延迟 206
5.4　本章小结 209
第三部分　虚拟机执行子系统
第6章　类文件结构 212
6.1　概述 212
6.2　无关性的基石 212
6.3　Class类文件的结构 214
6.3.1　魔数与Class文件的版本 215
6.3.2　常量池 218
6.3.3　访问标志 224
6.3.4　类索引、父类索引与接口索引集合 225
6.3.5　字段表集合 226
6.3.6　方法表集合 229
6.3.7　属性表集合 230
6.4　字节码指令简介 251
6.4.1　字节码与数据类型 251
6.4.2　加载和存储指令 253
6.4.3　运算指令 254
6.4.4　类型转换指令 255
6.4.5　对象创建与访问指令 256
6.4.6　操作数栈管理指令 256
6.4.7　控制转移指令 257
6.4.8　方法调用和返回指令 257
6.4.9　异常处理指令 258
6.4.10　同步指令 258
6.5　公有设计，私有实现 259
6.6　Class文件结构的发展 260
6.7　本章小结 261
第7章　虚拟机类加载机制 262
7.1　概述 262
7.2　类加载的时机 263
7.3　类加载的过程 267
7.3.1　加载 267
7.3.2　验证 268
7.3.3　准备 271
7.3.4　解析 272
7.3.5　初始化 277
7.4　类加载器 279
7.4.1　类与类加载器 280
7.4.2　双亲委派模型 281
7.4.3　破坏双亲委派模型 285
7.5　Java模块化系统 287
7.5.1　模块的兼容性 288
7.5.2　模块化下的类加载器 290
7.6　本章小结 292
第8章　虚拟机字节码执行引擎 293
8.1　概述 293
8.2　运行时栈帧结构 294
8.2.1　局部变量表 294
8.2.2　操作数栈 299
8.2.3　动态连接 300
8.2.4　方法返回地址 300
8.2.5　附加信息 301
8.3　方法调用 301
8.3.1　解析 301
8.3.2　分派 303
8.4　动态类型语言支持 315
8.4.1　动态类型语言 316
8.4.2　Java与动态类型 317
8.4.3　java.lang.invoke包 318
8.4.4　invokedynamic指令 321
8.4.5　实战：掌控方法分派规则 324
8.5　基于栈的字节码解释执行引擎 326
8.5.1　解释执行 327
8.5.2　基于栈的指令集与基于寄存器的指令集 328
8.5.3　基于栈的解释器执行过程 329
8.6　本章小结 334
第9章　类加载及执行子系统的案例与实战 335
9.1　概述 335
9.2　案例分析 335
9.2.1　Tomcat：正统的类加载器架构 335
9.2.2　OSGi：灵活的类加载器架构 338
9.2.3　字节码生成技术与动态代理的实现 341
9.2.4　Backport工具：Java的时光机器 345
9.3　实战：自己动手实现远程执行功能 348
9.3.1　目标 348
9.3.2　思路 349
9.3.3　实现 350
9.3.4　验证 355
9.4　本章小结 356
第四部分　程序编译与代码优化
第10章　前端编译与优化 358
10.1　概述 358
10.2　Javac编译器 359
10.2.1　Javac的源码与调试 359
10.2.2　解析与填充符号表 362
10.2.3　注解处理器 363
10.2.4　语义分析与字节码生成 364
10.3　Java语法糖的味道 367
10.3.1　泛型 367
10.3.2　自动装箱、拆箱与遍历循环 375
10.3.3　条件编译 377
10.4　实战：插入式注解处理器 378
10.4.1　实战目标 379
10.4.2　代码实现 379
10.4.3　运行与测试 385
10.4.4　其他应用案例 386
10.5　本章小结 386
第11章　后端编译与优化 388
11.1　概述 388
11.2　即时编译器 389
11.2.1　解释器与编译器 389
11.2.2　编译对象与触发条件 392
11.2.3　编译过程 397
11.2.4　实战：查看及分析即时编译结果 398
11.3　提前编译器 404
11.3.1　提前编译的优劣得失 405
11.3.2　实战：Jaotc的提前编译 408
11.4　编译器优化技术 411
11.4.1　优化技术概览 411
11.4.2　方法内联 415
11.4.3　逃逸分析 417
11.4.4　公共子表达式消除 420
11.4.5　数组边界检查消除 421
11.5　实战：深入理解Graal编译器 423
11.5.1　历史背景 423
11.5.2　构建编译调试环境 424
11.5.3　JVMCI编译器接口 426
11.5.4　代码中间表示 429
11.5.5　代码优化与生成 432
11.6　本章小结 436
第五部分　高效并发
第12章　Java内存模型与线程 438
12.1　概述 438
12.2　硬件的效率与一致性 439
12.3　Java内存模型 440
12.3.1　主内存与工作内存 441
12.3.2　内存间交互操作 442
12.3.3　对于volatile型变量的特殊规则 444
12.3.4　针对long和double型变量的特殊规则 450
12.3.5　原子性、可见性与有序性 450
12.3.6　先行发生原则 452
12.4　Java与线程 455
12.4.1　线程的实现 455
12.4.2　Java线程调度 458
12.4.3　状态转换 460
12.5　Java与协程 461
12.5.1　内核线程的局限 461
12.5.2　协程的复苏 462
12.5.3　Java的解决方案 464
12.6　本章小结 465
第13章　线程安全与锁优化 466
13.1　概述 466
13.2　线程安全 466
13.2.1　Java语言中的线程安全 467
13.2.2　线程安全的实现方法 471
13.3　锁优化 479
13.3.1　自旋锁与自适应自旋 479
13.3.2　锁消除 480
13.3.3　锁粗化 481
13.3.4　轻量级锁 481
13.3.5　偏向锁 483
13.4　本章小结 485
附录A　在Windows系统下编译OpenJDK 6 486
附录B　展望Java技术的未来（2013年版） 493
附录C　虚拟机字节码指令表 499
附录D　对象查询语言（OQL）简介 506
附录E　JDK历史版本轨迹 512