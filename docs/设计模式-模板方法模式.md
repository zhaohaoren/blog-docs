# 【设计模式】模板方法模式

本文主要介绍模板方法模式的概念和用法。

## 模式背景

生活中，我们自己装主机，我们确定好机架后，里面的具体的CPU，内存条，电源，主板等等配件，就可以使用不同的方案去配置这个电脑主机了。这里面其实就是和模板方法模式相同的思想：机架也是可以有好多种的，那么每一种机架就相当于是一个模板。每一个机架可以有几套配件方案来进行配置，那么就要求，我们设计的这个模板的订制性很高，我们可以任意替换里面的配件，就是一个新构成的主机。

在平时的系统设计中也有大量这种类似的场景：我们实现某个功能的时候，需要多个步骤，这些步骤可能是固定的，也可能是不固定的（固定如：我必须装CPU和主板，不固定比如：我可以安装也可以不安装DVD机，我们可以装i7的CPU也可以装i5的等）。如果我们对于每种方案都单独写一个类，类中提供各个步骤的具体实现，存在2个问题：

1.  其中一个步骤的具体实现需要扩展，我们可能需要修改源代码去添加新的逻辑，这违背开闭原则（但是我们一般都不会这么做，直接继承就好了）。
2.  系统中有很多地方对这些步骤的执行顺序是有要求的，那么就需要客户端来自己控制这个顺序的准确性，客户端需要按照我们想要的顺序来，才会是正确的结果。这没有强约束性，我们无法保证客户端能永远使用正确，并且可能存在大量的执行这些步骤的重复性代码。

面对这些场景如何提高代码的复用性和系统的灵活性，就是模板方法模式需要解决的。

## 定义&概念

它定义一个操作中的算法的框架，而将一些步骤延迟到了子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。是一种类行为模式。

## 原理

首先，模板方法模式是一个结构很简单的设计模式。他只有一个继承结构。

然后，在使用模板模式前要梳理清楚系统中的2种方法：

- 基本方法： 指的是实现某一个功能，所有需要走的步骤。方法大小就看分的粒度。那些必走的步骤，我们可以将这些步骤放在父类中，大家统一来继承。那些不确定的步骤，我们可以把这些可能通过不同的实现类继承来创建。
- 模板方法：实现该功能的所有步骤的一个整体，我们可以叫模板方法。



**组成要素**

- 抽象类：定义了一系列的基本操作。这些操作可以是具体的也可以是抽象的。就是搭建一个算法的架子。
- 具体子类：实现抽象类的那些不确定的方法。

## UML

## 实现

抽象类

```java
public abstract class AbstractClass {

    /**
     * 模板方法
     */
    public void templateMethod() {
        op1();
        op2();
        op3();
    }

    /*
     * 基本方法
     */

    /**
     * 基本具体方法
     */
    public void op1() {
        System.out.println("op1");
    }

    /**
     * 基本抽象方法
     */
    public abstract void op2();

    /**
     * 钩子方法
     */
    public void op3() {

    }
}
```

具体子类

```java
public class ConcreteClass extends AbstractClass {
    @Override
    public void op2() {
        System.out.println("sub op2");
    }

    @Override
    public void op3() {
        System.out.println("sub op3");
    }
}
```

使用

```java
AbstractClass abstractClass = new ConcreteClass();
abstractClass.templateMethod();
```

## 优缺点

### 优点

### 缺点

## 使用场景

## 总结



# 附

相关代码：https://github.com/zhaohaoren/design_pattern_tutorial

如有代码和文章问题，还请指正！感谢！