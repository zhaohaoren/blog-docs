# 【设计模式】访问者模式

本文主要介绍

## 模式背景

一个集合里面有几类元素，不同类型的元素可以有不同的访问者访问他，并且有不同的访问执行逻辑。这时候如何很好的添加新的访问者而不需要修改代码就是访问者模式提供的。访问者模式可以不需要修改文件，只需要添加访问者，即可使用新的访问者来遍历元素。

## 定义&概念

提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式就是一种对象行为型模式。

## 原理

**组成要素**

- 抽象访问者
  - 主要是为了访问者的扩展。
  - 对集合元素中每一类元素都定义一个访问操作的抽象方法。可以通过函数名参数等明确知道哪个方法访问哪些类型的对象。
- 具体访问者
  - 实现抽象的访问逻辑。
- 抽象元素
  - 定义一个accept方法，参数通常就是抽象访问者。
- 具体元素
  - 实现accept完成对一个元素访问想要做的操作。本质就是调用传递来的抽象访问者的方法。
- 对象结构
  - 用来存放元素对象的。并提供遍历内部元素的方法。
  - 可以使用组合模式来实现。也可以是一个简单的集合对象。

## UML

![image-20200914204847619](/Users/zhaohaoren/workspace/mycode/blog-docs/docs/设计模式/visitor.png)

## 实现

抽象访问者

```java
public interface Visitor {
    void visit(ConcreteElementA concreteElementA);
    void visit(ConcreteElementB concreteElementB);
}
```

具体访问者

```java
public class ConcreteVisitorA implements Visitor {
    @Override
    public void visit(ConcreteElementA concreteElementA) {
        System.out.println("A visit:" + concreteElementA.getName());
    }

    @Override
    public void visit(ConcreteElementB concreteElementB) {
        System.out.println("A visit:" +concreteElementB.getName());
    }
}
```

抽象元素

```java
public interface Element {
    /**
     * 这accept对该类的元素传入一个accept。则集合中该元素都会使用该访问者处理。
     * 而这个访问者也实现了visit该元素的方法。所以传入this就可以重载到对应实现逻辑里面
     * @param visitor
     */
    void accept(Visitor visitor);
}
```

具体元素

```java
public class ConcreteElementA implements Element {

    private String name;

    public ConcreteElementA(String name) {
        this.name = name;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String getName() {
        return name;
    }
}
```

对象结构

```java
public class ObjectStructure {

    /**
     * 使用集合集合来存放所有的元素。
     */
    private List<Element> list = new ArrayList<>();

    public void addElement(Element e) {
        list.add(e);
    }

    public void removeElement(Element e) {
        list.remove(e);
    }

    /**
     * 使用某个访问者来遍历集合元素
     */
    public void accept(Visitor visitor) {
        list.forEach(item -> item.accept(visitor));
    }
}
```

使用

```java
Element e1, e2, e3, ee1, ee2, ee3;
ObjectStructure objectStructure = new ObjectStructure();
e1 = new ConcreteElementA("A1");
e2 = new ConcreteElementA("A2");
e3 = new ConcreteElementA("A3");
ee1 = new ConcreteElementA("B1");
ee2 = new ConcreteElementA("B2");
ee3 = new ConcreteElementA("B3");
objectStructure.addElement(e1);
objectStructure.addElement(e2);
objectStructure.addElement(e3);
objectStructure.addElement(ee1);
objectStructure.addElement(ee2);
objectStructure.addElement(ee3);
//可以通过配置来获取使用哪个访问类
Visitor v = new ConcreteVisitorA();
objectStructure.accept(v);
```

## 优缺点

### 优点

各角色职责分离，符合单一职责原则
通过UML类图和上面的示例可以看出来，Visitor、ConcreteVisitor、Element 、ObjectStructure，职责单一，各司其责。
具有优秀的扩展性
如果需要增加新的访问者，增加实现类 ConcreteVisitor 就可以快速扩展。
使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化
员工属性（数据结构）和CEO、CTO访问者（数据操作）的解耦。
灵活性

### 缺点

具体元素对访问者公布细节，违反了迪米特原则
CEO、CTO需要调用具体员工的方法。
具体元素变更时导致修改成本大
变更员工属性时，多个访问者都要修改。
违反了依赖倒置原则，为了达到“区别对待”而依赖了具体类，没有以来抽象
访问者 visit 方法中，依赖了具体员工的具体方法。



## 使用场景

## 总结

我们要根据具体情况来评估是否适合使用访问者模式，例如，我们的对象结构是否足够稳定，是否需要经常定义新的操作，使用访问者模式是否能优化我们的代码，而不是使我们的代码变得更复杂。



# 附

相关代码：https://github.com/zhaohaoren/design_pattern_tutorial

如有代码和文章问题，还请指正！感谢！