**天才万里挑一，世界上不可能那么多天才，世界上即使那么多天才，也不可能所有天才都立于万人之上。**起初也曾鄙视过刷算法，觉得考你算法这东西，本身就是考你的智商，刷了算是投机取巧。这一根筋的思想起源于一个错误的认知：我脑子就这么大地方，能去哪让脑子自己去决定，刷来的工作什么的，到时候你也不一定能胜任。这简直就是大错特错！人所有的认知都是基于学习而来的，再聪明，也很难从0到1，而刷题也是有一种学习！所以对学习为什么还要存在偏见？

刷题是一种**方法论**的学习过程，掌握更多的方法论其实可以给我们提供很多思路，这些思路对于一些聪明人往往在特定的场景下会做出卓越的突破（显然，我应该还不够，其实很多人都不够这级别），这就是这些方法论的价值。所以刷题没什么不对，面试遇到了你刷过的题目，做出来了，让你觉得不是自己脑子想出来的东西，感觉不真实，这是不正确的！因为工作几年了，真正进入社会这个大熔炉的时，也认识了一些曾经以为高不可攀的人，清华北大甚至MIT的娇子，发现他们大多真的很普通，他们也刷题，而且刷的比任何人都要勤奋。**很多智商是方法论的体现**，难题给你，你有方法解决那都是你的自己吸收了的能力所展现的，你掌握的方法越多，自然破解难题的可能性会越大，而且这种可能性大概率会超越，盖过生物学智力的差距。

总之，就是刷题无过，不刷傻逼。

方法论1

DFS BFS 搜索问题



方法论2

数学问题转换



方法论3

再丑陋，再傻瓜，也不要忘了，不要看不起最基本最原始的解法。没有更好的方法前，能把题目做出来就是好方法，管它黑猫白猫。



递归 先找到递归函数再写代码

递归如果递归中存在重复，可以使用空间换时间，将处理过的记录住，然后遇到了就不处理。这时候递归函数的参数列表就新加入一个记忆状态的数据结构参数。并且这时候原来的函数肯定不可以用了，我们应该创建新的函数，然后在这新的函数里面递归。









题目要反复的去刷，最后达到的境界，不用看题解，不用IDE，轻松写出代码。执行错误率极低。